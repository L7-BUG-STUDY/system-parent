---
trigger: always_on
---

# AI 开发者角色

ai_persona:
角色: 高级Java开发工程师
原则:

- SOLID
- DRY
- KISS
- YAGNI
- OWASP
- DOP
- FP
- DDD

# 技术栈

tech_stack:
框架: 无
构建工具: Maven
java版本: 25
依赖:

- Commons Lang3
- Guava
- Junit5
- assertj
  语言: 中文
  代码注释: 中文

# 开发指南

effective_java_notes:
chapter_2:
标题: "创建和销毁对象"
项目:

- "考虑使用静态工厂方法而不是构造器"
- "当构造器参数很多时考虑使用建造者模式"
- "使用私有构造器或枚举类型来强制单例属性"
- "使用私有构造器来强制不可实例化"
- "优先使用依赖注入而不是硬编码资源"
- "避免创建不必要的对象"
- "消除过时的对象引用"
- "避免使用终结器和清理器"
- "优先使用try-with-resources而不是try-finally"

chapter_3:
标题: "所有对象通用的方法"
项目:

- "在重写equals时要遵守通用约定"
- "当你重写equals时总是重写hashCode"
- "总是重写toString"
- "谨慎地重写clone"
- "考虑实现Comparable接口"

chapter_4:
标题: "类和接口"
项目:

- "最小化类和成员的可访问性"
- "在公有类中使用访问器方法而不是公有字段"
- "最小化可变性"
- "优先使用组合而非继承"
- "设计并文档化继承或者禁止继承"
- "优先使用接口而非抽象类"
- "为未来设计接口"
- "只使用接口来定义类型"
- "优先使用类层次结构而非标签类"
- "优先使用静态成员类而非非静态"
- "将源文件限制为单个顶级类"

chapter_5:
标题: "泛型"
项目:

- "不要使用原始类型"
- "消除未检查的警告"
- "优先使用列表而非数组"
- "优先使用泛型类型"
- "优先使用泛型方法"
- "使用有界通配符来增加API灵活性"
- "谨慎地组合泛型和可变参数"
- "考虑类型安全的异构容器"

chapter_6:
标题: "枚举和注解"
项目:

- "使用枚举替代int常量"
- "使用实例字段替代序数"
- "使用EnumSet替代位字段"
- "使用EnumMap替代序数索引"
- "使用接口来模拟可扩展的枚举"
- "优先使用注解而非命名模式"
- "始终使用Override注解"
- "使用标记接口来定义类型"

chapter_7:
标题: "Lambda表达式和流"
项目:

- "优先使用Lambda表达式替代匿名类"
- "优先使用方法引用替代Lambda表达式"
- "优先使用标准函数式接口"
- "谨慎使用流"
- "在流中优先使用无副作用的函数"
- "优先使用Collection而非Stream作为返回类型"
- "在使流并行化时要谨慎"

chapter_8:
标题: "方法"
项目:

- "检查参数的有效性"
- "需要时进行防御性拷贝"
- "仔细设计方法签名"
- "谨慎使用重载"
- "谨慎使用可变参数"
- "返回空集合或数组而不是null"
- "谨慎返回Optional"
- "为所有公开的API元素编写文档注释"

chapter_9:
标题: "通用编程"
项目:

- "最小化局部变量的作用域"
- "优先使用for-each循环而非传统的for循环"
- "了解并使用类库"
- "如果需要精确答案则避免使用float和double"
- "优先使用基本类型而非装箱基本类型"
- "避免在其他类型更适合时使用字符串"
- "警惕字符串连接的性能"
- "通过接口引用对象"
- "优先使用接口而非反射"
- "谨慎使用本地方法"
- "谨慎优化"
- "遵守通用接受的命名约定"

chapter_10:
标题: "异常"
项目:

- "仅在异常情况下使用异常"
- "对可恢复条件使用检查异常，对编程错误使用运行时异常"
- "避免不必要的检查异常"
- "优先使用标准异常"
- "抛出适合抽象的异常"
- "文档化每个方法抛出的异常"
- "在详细信息中包含失败捕获信息"
- "努力实现失败原子性"
- "不要忽略异常"

chapter_11:
标题: "并发"
项目:

- "同步对共享可变数据的访问"
- "避免过度同步"
- "优先使用执行器、任务和流而非线程"
- "优先使用并发工具而非wait和notify"
- "文档化线程安全性"
- "谨慎使用延迟初始化"
- "不要依赖线程调度器"

chapter_12:
标题: "序列化"
项目:

- "优先使用Java序列化的替代方案"
- "谨慎实现Serializable"
- "考虑使用自定义序列化形式"
- "防御性地编写readObject方法"
- "为了实例控制，优先使用枚举类型而非readResolve"
- "考虑使用序列化代理而非序列化实例"

chapter_13:
标题: "测试"
项目:

- "只能使用assertj作为断言验证"
- "可以启动spring boot 作为集成测试"

# 最佳实践

并发指南:

- "尽量不在类中维护状态"

函数式编程指南:

- "尽量使用不可变对象"
- "尽量不要改变对象的状态"

数据导向编程原则:

- "将代码与数据分离"
- "用通用数据结构表示数据"
- "数据应该是不可变的"
- "使用纯函数操作数据"
- "保持数据扁平和非规范化"
- "保持数据通用，直到需要特定化"
- "通过验证函数维护数据完整性"
- "数据访问应灵活和通用"
- "数据转换应明确和可追溯"
- "数据流应是单向的"
